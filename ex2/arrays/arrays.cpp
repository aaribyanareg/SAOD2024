
#include <iostream>
using namespace std;

/*
// Задание №6
//Шаг a: cозда функциb, которая выполняет циклическую перестановку массива 
void rotate(int a[], int n) {
	int x = a[0]; // Сохраняем первый элемент массива
	for (int i = 1; i < n; i++) {
		a[i - 1] = a[i]; // Сдвигаем элементы массива
	}
	a[n - 1] = x; // Помещаем первый элемент на последнюю позицию
}
// Шаг с: реализация функции через указатели
void rotatePointers(int a[], int n) {
	int x = a[0]; // Сохраняем первый элемент массива
	for (int* p = a + 1; p < a + n; p++) {
		*(p - 1) = *p; // Сдвигаем элементы массива
	}
	a[n - 1] = x; // Помещаем первый элемент на последнюю позицию
}
//Шаг b: проверить, что функция работает или добиться, чтобы работала
int main() {
	int a[] = { 1, 2, 3, 4, 5 };
	int n = sizeof(a) / sizeof(a[0]); // Определяем размер массива

	rotate(a, n); // Выполняем циклическую перестановку
	rotatePointers(a, n); // Выполняем циклическую перестановку
	// Выводим результат
	for (int i = 0; i < n; i++) {
		cout << a[i] << " ";
	}
	cout << endl;
}


//Задание 5
int main()
{
	// Шаг b: объявление массива в одну строку
	int a[5]{ 1,2,3,4,5 };
	for (int i = 0; i < 5; i++)
		cout << a[i] << ' ';
	cout << endl;
	// Шаг c: вывод массива с помощью указателя на целое
	//Цикл выполняется, пока разность между текущим положением указателя p и начальным адресом массива a меньше длины массива.
	for (int* p = a; p - a < 5; p++) //p-a<5 проверяет, насколько далеко указатель p продвинулся по массиву от его начала 
		cout << *p << ' ';
	cout << endl;
	//Что обеспечивает инициализатор:
		//В первом цикле инициализатор i = 0 устанавливает начальный индекс для перебора элементов массива.
		//Во втором цикле инициализатор int* p = a; устанавливает указатель p на начало массива, что позволяет начать итерацию с первого элемента.
	// В чем заключается условие:
		//В первом цикле условие i < 5 гарантирует, что цикл будет итерировать от начала до конца массива, не выходя за его пределы.
		//Во втором цикле условие p - a < 5 использует арифметику указателей для проверки, 
		//не превысил ли указатель p допустимый диапазон элементов массива.
		//Поскольку p-a дает количество элементов от начала массива до текущего положения p, 
		//сравнение этой разности с размером массива(5) гарантирует, что цикл не выйдет за границы массива.
	// почему оно правильное:
		//Это условие правильно, потому что оно точно отражает, 
		//сколько элементов уже было обработано, и останавливает цикл, когда все элементы массива были обработаны.
}
*/